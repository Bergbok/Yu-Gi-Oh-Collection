---
import UpArrow from '../assets/arrow-up.svg';
import { getCollection } from 'astro:content';
import type { Card as YuGiOhCard } from '../types/yugioh';

const cards = await getCollection('cards');
const cardSets = await getCollection('cardsets');

const cardsBySet = cards.reduce<Record<string, YuGiOhCard[]>>((acc, card) => {
	const setCode = card.data.card_number.split('-')[0];
	if (!acc[setCode]) {
		acc[setCode] = [];
	}
	acc[setCode].push(card.data);
	return acc;
}, {});
---

<div id='controls'>
	<div id='filter-container'>
		<label for='filter-set'>Filter By Set:</label>
		<select id='filter-set'>
			<option value='all'>All Sets</option>
			{Object.keys(cardsBySet).sort().map(set => {
				const setObject = cardSets.find(cs => cs.data.set_code === set);
				return setObject && <option value={setObject.id}>{setObject.id} ({cardsBySet[set].length}/{setObject?.data.num_of_cards})</option>
			})}
		</select>
	</div>

	<div id='sort-container'>
		<label for='sort-cards'>Sort By:</label>
		<div class='sort-controls'>
			<select id='sort-cards'>
				<option value='atk'>ATK</option>
				<option value='attribute'>Attribute</option>
				<option value='card number'>Card Number</option>
				<option value='count'>Count</option>
				<option value='def'>DEF</option>
				<option value='edition'>Edition</option>
				<option value='level'>Level</option>
				<option value='name' selected>Name</option>
				<option value='price'>Price Average</option>
			</select>
			<button id='sort-direction' data-direction='asc' title='Sort Ascending'>
				<UpArrow />
			</button>
		</div>
	</div>
</div>

<script>
const cardGrid = document.querySelector('#card-grid') as HTMLElement;
const sortDirButton = document.querySelector('#sort-direction') as HTMLButtonElement;
const sortSelect = document.querySelector('#sort-cards') as unknown as HTMLSelectElement;
const filterSelect = document.querySelector('#filter-set') as unknown as HTMLSelectElement;

function sortCards() {
	const cards = Array.from(cardGrid.children) as HTMLElement[];
	const sortBy = sortSelect.value;
	const sortDir = sortDirButton.dataset.direction || 'asc';
	const filterSet = filterSelect.value.split('-')[0].trim();

	cards.forEach(card => {
		if (filterSet === 'all' || card.dataset.cardNumber?.startsWith(filterSet)) {
			card.style.display = '';
		} else {
			card.style.display = 'none';
		}
	});

	const sortedCards = cards
		.filter(card => card.style.display !== 'none')
		.sort((a, b) => {
			if (sortDir === 'desc') [a, b] = [b, a];

			switch (sortBy) {
				case 'name':
					return a.title.localeCompare(b.title);
				case 'edition':
					return (a.dataset.edition || '').localeCompare(b.dataset.edition || '');
				case 'count':
					return parseInt(a.dataset.count || '0') - parseInt(b.dataset.count || '0');
				case 'card number':
					return (a.dataset.cardNumber || '').localeCompare(b.dataset.cardNumber || '');
				case 'attribute':
					return ((a.querySelector('.title-overlay .attribute') as HTMLElement)?.title || '').localeCompare((b.querySelector('.title-overlay .attribute') as HTMLElement)?.title || '');
				case 'atk':
					if (sortDir === 'desc') [a, b] = [b, a];

					const aAtk = parseInt((a.querySelector('.title-overlay .atk') as HTMLElement)?.title.split(' ')[1] || '0');
					const bAtk = parseInt((b.querySelector('.title-overlay .atk') as HTMLElement)?.title.split(' ')[1] || '0');

					if (aAtk === 0 && bAtk === 0) return 0;
					if (aAtk === 0) return 1;
					if (bAtk === 0) return -1;

					return sortDir === 'desc' ? bAtk - aAtk : aAtk - bAtk;
				case 'def':
					if (sortDir === 'desc') [a, b] = [b, a];

					const aDef = parseInt((a.querySelector('.title-overlay .def') as HTMLElement)?.title.split(' ')[1] || '0');
					const bDef = parseInt((b.querySelector('.title-overlay .def') as HTMLElement)?.title.split(' ')[1] || '0');

					if (aDef === 0 && bDef === 0) return 0;
					if (aDef === 0) return 1;
					if (bDef === 0) return -1;

					return sortDir === 'desc' ? bDef - aDef : aDef - bDef;
				case 'level':
					if (sortDir === 'desc') [a, b] = [b, a];

					const aLevel = parseInt((a.querySelector('.title-overlay .level') as HTMLElement)?.title.split(' ')[1] || '0');
					const bLevel = parseInt((b.querySelector('.title-overlay .level') as HTMLElement)?.title.split(' ')[1] || '0');

					if (aLevel === 0 && bLevel === 0) return 0;
					if (aLevel === 0) return 1;
					if (bLevel === 0) return -1;

					return sortDir === 'desc' ? bLevel - aLevel : aLevel - bLevel;
				case 'price':
					const aPrice = parseFloat(a.dataset.averagePrice || '0');
					const bPrice = parseFloat(b.dataset.averagePrice || '0');

					if (aPrice === 0 && bPrice === 0) return 0;
					if (aPrice === 0) return 1;
					if (bPrice === 0) return -1;

					return aPrice - bPrice;
				default:
					return 0;
			}
		});

	sortedCards.forEach(card => cardGrid.appendChild(card));
}

function toggleSortDirection() {
	const newDir = sortDirButton.dataset.direction === 'asc' ? 'desc' : 'asc';
	sortDirButton.dataset.direction = newDir;
	sortDirButton.title = newDir === 'asc' ? 'Sort Ascending' : 'Sort Descending';
	sortCards();
}

sortDirButton.addEventListener('click', toggleSortDirection);
filterSelect.addEventListener('change', sortCards);
sortSelect.addEventListener('change', sortCards);

sortCards();
</script>

<style>
#controls {
	align-items: center;
	background-color: #F2A0801C;
	border-radius: 0.5rem;
	color: silver;
	display: flex;
	flex-wrap: nowrap;
	height: 100%;
	gap: 1rem;
	justify-content: center;
	padding: 1.5rem;

	& div {
		align-items: center;
		display: flex;
		gap: 0.5rem;
		flex-shrink: 1;

		& label {
			font-size: 0.9rem;
			font-weight: 500;
			white-space: nowrap;
		}

		& select {
			background-color: #231A11;
			border-radius: 0.25rem;
			border: none;
			color: inherit;
			cursor: pointer;
			font-size: 0.9rem;
			padding: 0.4rem 0.8rem;
			min-width: 80px;

			&:hover {
				background-color: #80522C;
			}
		}

		&#filter-container select {
			max-width: 200px;
			width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		& button {
			align-items: center;
			background-color: #231A11;
			border-radius: 0.25rem;
			border: none;
			cursor: pointer;
			display: flex;
			justify-content: center;
			padding: 0.4rem 0.8rem;
			transition: all 0.2s ease;
			flex-shrink: 0;
			transform: scale(0.95);

			&:hover {
				background-color: #80522C;
			}

			&[data-direction='desc'] svg {
				transform: rotate(180deg);
			}

			& svg {
				fill: silver;
				transition: transform 0.2s ease;
				width: 1rem;
			}
		}


		& .sort-controls {
			display: flex;
			align-items: center;
			gap: 0.5rem;
		}
	}
}

@media (max-width: 550px) {
	#controls {
		gap: 0.75rem;
		padding: 1rem;

		& div {
			& label {
				font-size: 0.8rem;
				text-align: center;
			}

			& select {
				font-size: 0.8rem;
				padding: 0.3rem 0.6rem;
				min-width: 60px;
			}

			& button {
				padding: 0.3rem;

				& svg {
					width: 0.9rem;
				}
			}


			&#filter-container {
				flex-direction: column;
				align-items: center;
				gap: 0.25rem;

				& select {
					max-width: none;
					width: 100%;
				}
			}


			&#sort-container {
				flex-direction: column;
				align-items: center;
				gap: 0.25rem;

				& .sort-controls {
					display: flex;
					align-items: center;
					gap: 0.5rem;
				}
			}
		}
	}
}
</style>
